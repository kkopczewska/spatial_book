?cor
help("cor")

?? correlation
help.search("correlation")

apropos("cor")

library(help="stats")

example("cor")
cor> var(1:10)  

cor> var(1:5, 1:5) 


cor> ## Two simple vectors
cor> cor(1:10, 2:11) 

cor> ## Correlation Matrix of Multivariate sample:
cor> (Cl <- cor(longley))

cor 	# only the beginning and end of the command code will be shown

help.start()

demo(colors)

search()

update.packages()

library("spdep")

requiredPackages<-c("sp", "spdep", "RColorBrewer") # a list of packages
for(i in requiredPackages){
  if(!require(i,character.only = TRUE)) install.packages(i)
  library(i,character.only = TRUE) }

detach("package:spdep", unload=TRUE)

getwd() # checking the current working directory
setwd("C:/R/Data/") # setting the required working directory - example

library(foreign) # library supporting additional file formats
getwd() # checks the location of the default directory

# loading from a text file
data1<-read.table("data.txt", header=TRUE, sep="\t", encoding="UTF-8") 

# loading from a CSV file
data2<-read.csv("data.csv",header=TRUE, sep=";",dec=".", encoding="UTF-8")

# loading from tab delimited file
data3<-read.delim("data.dat", header=FALSE, sep="\t") 

# loading from a dbf file
data4<-read.dbf("data.dbf") 

# loading from the SPSS format
data5<-read.spss("data.sav", use.value.labels=FALSE, to.data.frame=TRUE) 

# loading from the STATA format
data6<-read.dta("data.dta", convert.factors=FALSE) 

library(gdata)
data7 = read.xls ("myfile.xlsx", sheet = 1, header = TRUE)

3+5

vector1<-c(1,2,3,4,5) # vector of numbers 1,2,3,4,5
vector2<-10:20 # vector of integers from 10 to 20
vector3<-seq(5,10,0.2) # a sequence of numbers from 5 to 10 with a step of 0.2

data<-read.csv("Data/dataset2s.csv", header=TRUE, sep=";", dec=",", encoding="UTF-8")

names(data)

class(data)
#[1] "data.frame"

# converting data to the data.frame class object if possible 
# and create a new object if needed
data.df<-as.data.frame(data) 
str(data) # structure of the object

attributes(dane) # object attributes

vector3<-seq(5,10,0.2) # vector reminder
new vector3<-vector3 # assignment to a new name
new vector3# display of the object

rm(vector3) # deleting from the object's memory vector3

x<-seq(1, 20, 0.4) # generating a variable x
y<-seq(2,21,0.4)  # generating a variable y
z<-seq(3,22,0.4)  # generating a variable z
xyz<-cbind(x,y,z)  # combining variables into one xyz object 
head(xyz) # display the beginning of the xyz object
names(xyz)  # request to display headers
# adding new names of columns and rows
colnames(xyz)<-c("variable x", "variable y", "variable from")
rownames(xyz)<-rownames(xyz, do.NULL = FALSE, prefix = "Obs.")

is.data.frame(xyz)  # checking if xyz is a data.frame object
xyz.df<-as.data.frame(xyz)  # xyz conversion to data frame

head(xyz.df)  # displaying the xyz object after changes

names(xyz.df)  # request to display column headers

colnames(xyz.df)  # request to display column headers

head(rownames(xyz.df))  # request to display row headers

unempl<-data$XA06
head(unempl)

# observations from 1 to 10 with variables from columns 3 to 5
section<-data[1:10, 3:5] 

section

# only rows 2,7,10,15 and all columns
section 2<-data[c(2,7,10,15), ]

# rows 1 to 10, but without a selected column - here is the fifth 
# character (-) deletes the given row or column from the result
section3<-data[1:10,-5] 

data15<-data[data$year==2015,]
head(data15)

podkarp.or.opol<-data15[data15$voivodeship=="Opolskie" | 
                           data15$voivodeship=="Podkarpackie", ]

# combining several variables into one object
employment<-cbind(data15$XA03, data15$XA04, data15$XA05) 

# limiting the collection for increased transparency
employment<-as.data.frame(employment[1:6, ]) 

# giving new headers
colnames(employment)<-c("agriculture", "industry", "services") 

# displaying the object's content
employment
# a new object containing a marker (ind) and values
# displaying the content of the object after the stack() function  
zat.stack<-stack(employment) 
zat.stack 

unstack(zat.stack) # return to the original data

data15$XA17a<-data15$XA17 # creating a copy of variable XA17, new name XA17a

# creating missing observations coded as 99999
data15$XA17a[c(3,5,9,10)]<-99999 

head(data15$XA17a,12) # display of the first 12 data of variable XA17a

# assigning NA to missing observations
is.na(data15$XA17a)<-data15$XA17a>=99998 

head(data15$XA17a,12) # displaying the first 12 data of variable XA17a again

summary(data15)

employment<-as.data.frame(cbind(data15$XA03, data15$XA04, data15$XA05))
colnames(employment)<-c("agriculture”, “industry”, “ services ") 

# average calculated from all data.frame object variables using lapply()
lapply(employment,mean,na.rm=T)

# average calculated from all data.frame object variables using sapply()
sapply(employment,mean,na.rm=T) 

# average calculated for one variable (column) with data.frame objects
mean(employment$service, on.rm = TRUE)

var1<-rnorm(1000) # drawn 1000 numbers from the normal distribution
quantile(var1)

# determination of probability thresholds by the user
quantile(var1,  probs=c(1,2,5,95,98,99)/100) 

fivenum(data15$XA06) # position statistics for the variable unemployment in 2015

class(data$voivodeship) # checking if the variable is factor

levels(data$voivodeship) # number of classes / levels

nlevels(data$voivodeship)  # number of classes / levels

cor(data15$XA06,data15$XA30)

cor.test(data15$XA06,data15$XA30)

# employed per capita - the number of employees divided by the total population
# new variable empl.pc, added to the data15 object
data15$empl.pc<-data15$XA02/(data15$XA19+data15$XA20+data15$XA21)

# creating a new object containing only variables: 
# unemployment rate, remuneration, employed per capita
variables.df<-data.frame(cbind(data15$XA06, data15$XA30, data15$empl.pc))
colnames(variables.df)<-c("enemployment rate", "remuneration", "employed per capita")

# correlation matrix, the rounding function was used 
# up to two decimal places to increase readability
round(cor(variables.df, use="pairwise"),2)

# correlation chart
pairs(variables.df) 

variable<-data15$XA30

# standardising expression variable - the new variable is Z_ variable
Z_ variable <-( variable-mean(variable))/sd(variable)

# the average of the standardized variable is irrelevant diffrent to zero, very close to zero
mean(Z_ variable)

# the variance is equal to 1
var(Z_ variable)

zmienna1<-data15$XA30
Z_zmienna1<-scale(variable1) # variable standardised
mean(Z_ variable1)
var(Z_ variable1)

data<-read.csv("Data/dataset2s.csv", header=TRUE, sep=";", dec=",", encoding="UTF-8")

# aggregation of data with respect to the year
unemployment <-aggregate(data$XA06, by=list(data$year), mean, na.rm=TRUE) 
unemployment

par(mfrow=c(1,2), mar=c(2,2,2,1))
plot(unemployment$x) # the simplest dot chart

# line chart with additional options
plot(unemployment$x, type= "l", lwd=2, axes=FALSE, xlab="year", ylim=c(10,20))
axis(1, at=1:10, labels=unemploymet$Group.1, cex=0.8)
axis(2)
abline(h=(5:10)*2, lty=3)
abline(v=(1:10)*1, lty=3)
points(unemploymet$x, pch=21, bg="red", cex=1.5)
title(main=" Average unemployment rate in Poland based on poviat data", cex.main=0.8)
legend(3,20, pch=21, pt.bg="red", col="black", lwd=2, c("unemployment rate"), bty="n", cex = 0.6)
text(1:10, unemploymet$x+0.5, round(unemploymet$x,2), cex=0.6)

x<-seq(1,25,1) # generating the x variable
y<-2*x^2  # generating the y variable
# dividing the chart area into parts, and determining the margins
par(mfrow=c(2,3), mar=c(2,2,2,2)) 
plot(y, type="p", main="typ p") # as plot() without the type parameter =
plot(y, type="l", main="typ l")
plot(y, type="o", main="typ o")
plot(y, type="h", main="typ h")
plot(y, type="s", main="typ s")
plot(y, type="S", main="typ S")

# loading of data
data<-read.csv("Data/dataset2s.csv", header=TRUE, sep=";", dec=",", encoding="UTF-8")

# Fig. 1.17a
pprod<-aggregate(data$XA19, by=list(data$year), sum, na.rm=TRUE)
colnames(pprod)<-c("year","l_pprod")

# the names.arg option gives labels under the bars
barplot(pprod$l_pprod/1000, col="grey", ylim=c(0,8000), ylab="in thous.",
        names.arg = pprod$year, cex.axis=0.8, main=" Population in the pre-productive age ", cex.names=0.8) 
abline(h=c(6000,7000,8000), lty=3, col="red") # help lines

# Fig.1.17b
# stacked bar graph
preprod<-aggregate(data$XA19, by=list(data$year), sum, na.rm=TRUE)
prod<-aggregate(data$XA20, by=list(data$year), sum, na.rm=TRUE)
postprod<-aggregate(data$XA21, by=list(data$year), sum, na.rm=TRUE)
ludnosc<-cbind(preprod, prod$x, postprod$x)
colnames(population)<-c("year", "predpr", "prod", "postprod")

# converting the data.frame object to the matrix to the barplot command
population.m<-as.matrix(population) 
barplot(t(population.m[,2:4]/1000), ylim=c(0,40000), names.arg= population.m[,1], cex.axis=0.8, 
        legend.text=TRUE, args.legend=list(x="right", bg="white"), cex.names=0.8, main="Population structure by years")
abline(h= population.m[1,2]/1000, lty=3, lwd=2, col="blue")
abline(h=sum(population.m[1,2:3]/1000), lty=3, lwd=2, col="blue")
abline(h=sum(population.m[1,2:4]/1000), lty=3, lwd=2, col="blue")

t(population.m[,2:4])

data15<-data[data$year==2015,]
structure<-aggregate(cbind(XA19, XA20, XA21) ~ voivodeship, data= data15, sum)
colnames(structure)<-c("voivodeship", "Pre-productively," "productively", "Post-productively")
structure_m<-structure[structure$voivodeship=="Mazowieckie",]
structure_m<-structure_m[2:4] # deleting the name of the voivodeship

# dividing the chart area into 2 parts, and determining the margins
par (mfrow=c(1,2), mar=c(2,2,2,2))
# converting the data.frame object into a numeric vector
pie(as.numeric(structure_m), labels=names(structure_m), cex=0.6) 

library(plotrix) # loading the required package
pie3D(as.numeric(structure_m),edges=1000,radius=1.3,height=0.2,theta=pi/4,start=0, explode=0.20, col=heat.colors(3),labels=names(structure_m), labelcex=0.7)
title(main=" Structure of the population of the voivodeship Mazowieckie", cex.main=0.7)

data<-read.csv("Data/dataset2s.csv", header=TRUE, sep=";", dec=",", encoding="UTF-8")
data15<-data[data$year==2015,]
boxplot(data15$XA06, col="grey78", ylab="unemployment rate", 
        main=" Unemployment rate in poviats in 2015")

a<-aggregate(data15$XA06, by=list(data15$voivodship), mean, na.rm=TRUE)
a$ID<-c(1:16)
colnames(a)<-c("woj", "x", "ID")
boxplot(data15$XA06~data15$voivodship, axes=FALSE, ylim=c(0,65), col="bisque", border="bisque4")

# average unemployment rate line
abline(h=mean(data15$XA06, na.rm=TRUE), lty=3, col="red") 

# axis
axis(1, at=1:16, labels=a$ID, cex.axis=0.8)
axis(2, at=(0:6)*10, cex.axis=0.8, ylab="%")

# legend text
for(i in 1:16){
text(1,65-2.3*i, a$ID[i], cex=0.6)
text(3,65-2.3*i, a$woj[i], cex=0.6)}

title(main="The unemployment rate in 2015 by voivodships", cex.main=0.8,
      sub="Data aggregated from the level of poviats", cex.sub=0.7)


head(colors(),12)

plot(log(data15$XA30),data15$XA06, xlab="Logarithm of average salary in PLN", ylab="Registered unemployment rate (in%)")

model1<-lm(XA06~log(XA30), data=data15)
model1  # regression result - basic version

summary(model1) # regression result - full version
plot(log(data15$XA30),data15$XA06, xlab="Logarithm of average salary in PLN", ylab="Registered unemployment rate (in%)")
abline(model1)

intercept<-model1$coefficients[1]  # isolation of the free word
slope<-model1$coefficients[2] # extracting the slope of the regression line

intercept
slope

par(mfrow=c(1,2)) # option to show two charts side by side
res<-residuals(model1) 
plot(res, ylab="Residual") 
abline(h=0, lty=2)  
title(main=" Residual point chart")

# histogram of residuals
hist(res, breaks=30, main="Residual histogram", freq = FALSE, xlab="Residual")

# creation of the normal distribution density function 
# with parameters consistent with the empirical distribution of the rest
mean.res<-mean(res)
sd.res<-sd(res)
x<-seq(min(res), max(res),length=100)
y<-dnorm(x, mean.res, sd.res)
lines(x,y)  # line of theoretical normal distribution

model1.fit<-predict(model1)  # theoretical values obtained from the model 
# error as a difference between empirical and theoretical values 
error<-data15$XA06-model1.fit 

shapiro.test(data15$XA30) # normality test for the distribution of unemployment variable

shapiro.test(res) # normality test of residual distribution 

 
1


